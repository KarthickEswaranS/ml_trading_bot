import keyring
from binance import Client
import pandas as pd
from sklearn.model_selection import TimeSeriesSplit
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, accuracy_score
import numpy as np
import matplotlib.pyplot as plt
import mplfinance as mplf


class data:

    def __init__(self):
        api_key = keyring.get_password('binance', 'api_key')
        api_secret = keyring.get_password('binance', 'api_secret')
        self.client = Client(api_key, api_secret)
        self.hist_data = self.client.get_historical_klines(
            'BTCUSDT',Client.KLINE_INTERVAL_1DAY,
            '1-1-2023',
            '1-1-2025',
        )

    def data_cleaning(self):
        df = pd.DataFrame(self.hist_data)
    
        df.columns = ['Open Time', 'Open', 'High', 'Low', 'Close',
                       'Volume', 'Close Time','Quote Asset Volume',
                       'Number of Trades', 'Taker Buy Base Asset Volume',
                        'Taker Buy Quote Asset Volume', 'Ignore']
       
        df['Open Time'] = pd.to_datetime(df['Open Time'], unit= 'ms')
        df['Close Time'] = pd.to_datetime(df['Close Time'], unit= 'ms')
        to_numeric_data = ['Open', 'High', 'Low', 'Close', 'Volume', 'Quote Asset Volume', 'Taker Buy Base Asset Volume', 'Taker Buy Quote Asset Volume']
        df[to_numeric_data] = df[to_numeric_data].apply(pd.to_numeric)
    
        df = df.set_index(df['Open Time'])
        df = df.drop(columns=['Open Time'])

        # print(df.head())
        # self.feature(df)
        return df
    
    def feature(self, dataframe):
        df = dataframe
        df['ret_1'] = df['Close'].pct_change(1) # % change from yesterday
        df['ret_3'] = df['Close'].pct_change(3) # % change from  3 day before
        df['ma_5']  = df['Close'].rolling(5).mean() # 5 day moving average(fast)
        df['ma_10'] = df['Close'].rolling(10).mean() # 10 day moving average (medium)
        df['ma_20'] = df['Close'].rolling(20).mean() # 20 day moving average (slow)
        df['std_10'] = df['Close'].rolling(10).std() # flacutuation in the market (standard devation)
        df['mom_5'] = df['Close'] - df['Close'].shift(5) # Momentum means speed of movement

        # Simple RSI implementation (14-period)
        delta = df['Close'].diff()
        up = delta.clip(lower=0)
        down = -1 * delta.clip(upper=0)
        roll_up = up.rolling(14).mean()
        roll_down = down.rolling(14).mean()
        rs = roll_up / (roll_down + 1e-9)
        df['rsi'] = 100 - (100 / (1 + rs))
        # Drop NA rows generated by indicators
        df = df.dropna().copy()

        # LABEL CREATION
        threshold = 0.001
        df['target_ret'] = df['Close'].shift(-1)/ df['Close']-1
        df['target'] = (df['target_ret'] > threshold).astype(int)
        df = df[:-1]

        # print(df.head())

        return df
    
    def train_test(self, dataframe):
        df = dataframe
        indicators = ['ret_1','ret_3','ma_5','ma_10','ma_20','std_10','mom_5','rsi']
        X = df[indicators].values
        y = df['target'].values

        tscv = TimeSeriesSplit(n_splits=5)
        # print(tscv)

        # We'll perform a simple train-test split: last 20% as test
        split_index = int(len(df) * 0.8)
        X_train, X_test = X[:split_index], X[split_index:]
        y_train, y_test = y[:split_index], y[split_index:]
        dates_train = df.index[:split_index]
        dates_test = df.index[split_index:]

        # Scale features
        scaler = StandardScaler()
        X_train_scaled = scaler.fit_transform(X_train)
        X_test_scaled = scaler.transform(X_test)
      

        # MODEL TRAINING
        model = RandomForestClassifier(n_estimators=200, max_depth=5, random_state=42, n_jobs=-1)
        model.fit(X_train_scaled, y_train)

        # Predictions
        y_pred = model.predict(X_test_scaled)
        y_proba = model.predict_proba(X_test_scaled)[:, 1]

        print('=================Final Result===============')
        print("Test accuracy:", accuracy_score(y_test, y_pred))
        print('-----------------Test Report-----------------')
        print(classification_report(y_test, y_pred))

        # Feature importances
        importances = pd.Series(model.feature_importances_, index=indicators).sort_values(ascending=False)
        print('-----------------Feature importances-----------------')
        print("Feature importances:\n", importances)
        print("Feature importances:\n", importances.idxmax())

        return y_pred,y_proba
        

    def backtest(self, dataframe, prediction, index):
        df = dataframe
        split_index = index
        y_pred,y_proba = prediction
     

        test_df = df.iloc[split_index:].copy()
        test_df['y_pred'] = y_pred
        test_df['y_proba'] = y_proba
        test_df['next_open'] = test_df['Open'].shift(-1) 
        test_df['strategy_ret'] = 0.0
        test_df['strategy_ret'] = test_df['target_ret'] * test_df['y_pred']

        # Cumulative returns
        test_df['cum_strategy'] = (1 + test_df['strategy_ret']).cumprod()
        test_df['cum_buy_and_hold'] = (1 + test_df['target_ret']).cumprod()

       
        ann_sharpe = self.sharpe(test_df['strategy_ret'].values, period=252)
        ann_sharpe_bh = self.sharpe(test_df['target_ret'].values, period=252)
        total_return = test_df['cum_strategy'].iloc[-1] - 1
        bh_return = test_df['cum_buy_and_hold'].iloc[-1] - 1

        print('-----------------Sharpe Ratio-----------------')
        print(f"Strategy total return: {total_return:.2%}, \nSharpe (ann): {ann_sharpe:.2f}")
        print(f"Buy&Hold return: {bh_return:.2%}, \nSharpe (ann): {ann_sharpe_bh:.2f}")

        self.plot(test_df)
        return test_df

    def sharpe(self, returns, period=252):
        # returns: series of periodic returns
        mean = np.nanmean(returns)
        std = np.nanstd(returns)
        if std == 0:
            return np.nan
        return (mean / std) * np.sqrt(period)
    
    def plot(self, dataframe):
        df = dataframe
        # Create "long signals" for mplfinance
        df['Long_Signal'] = np.where(df['y_pred'] == 1, df['Close'], np.nan)

        # Select last 200 candles
        # n = 200
        # subset = df.tail(n)

        # Addplot for long signals
        long_ap = mplf.make_addplot(
            df['Long_Signal'],
            type='scatter',
            marker='^',
            markersize=100,
            color='brown'
        )

        # Plot with mplfinance
        mplf.plot(
            df,
            type='candle',
            style='yahoo',
            addplot=[long_ap],
            title=f"ML Predicted LONG Signals)",
            volume=True,
            figsize=(14, 7)
        )
        print(df)
        # plt.figure(figsize=(12,6))
        # plt.plot(df.index, df['cum_strategy'], label='Strategy')
        # plt.plot(df.index, df['cum_buy_and_hold'], label='Buy & Hold', alpha=0.7)
        # plt.legend()
        # plt.title("Cumulative Returns - Strategy vs Buy & Hold")
        # plt.xlabel("Date")
        # plt.ylabel("Cumulative Return")
        # plt.show()

        # Plot signals on price chart (last 200 bars)
        # n = 200
        # subset = df.tail(n)
        # plt.figure(figsize=(14,6))
        # plt.plot(subset.index, subset['Close'], label='Close Price')
        # longs = subset[subset['y_pred'] == 1]
        # plt.scatter(longs.index, longs['Close'], marker='^', color='green', label='Predicted LONG', s=50)
        # plt.legend()
        # plt.title("Price with Predicted Long Signals (last {} bars)".format(n))
        # plt.show()


c = data()
d = c.data_cleaning()
f = c.feature(d)
t = c.train_test(f)

split_index = int(len(f) * 0.8)

b = c.backtest(f,t, split_index)
